/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   aes_ctr.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: stales <stales@student.42angouleme.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 12:46:51 by stales            #+#    #+#             */
/*   Updated: 2024/12/10 22:57:36 by stales           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
 * 										AES Algorithm
 *
 * 	Cipher Key:
 * 		AES is a symmetric key encryption algorithm (The same key is used to encrypt and decrypt). 
 * 		It uses a cipher key whose length is 128 bits, 192 bits or 256 bits. 
 * 		The AES algorithm with a cipher key of length 128, 192, 256 bits is denoted 
 *		AES-128, AES-192, AES-256, respectively.
 *
 *
 *
 *	State:
 *		The process of encryption/decryption of plaintext/ciphertext to ciphertext/plaintext
 *		generates intermediate 128-bit results. These intermediate results are referred to as the
 *		State.
 *
 *
 *
 * 	Data Blocks:
 * 		AES operates on an input data block of 128 bits and its output is also a data block of
 * 		128 bits. 
 *
 * 		(Note) The size of an "Data blocks" is alway 128 bits even if use 192 or 256 bits AES algorithms
 * 		The principal difference reside in the key, the key size must be changed if you use AES-128,192 or 256 bits
 *		but not Data blocks.
 *
 *
 *
 *	Round Keys:
 *		AES-128, AES-192, and AES-256 algorithms expand the cipher key to 10, 12, and 14
 *		round keys, respectively. The length of each round key is 128 bits. The algorithm for
 *		deriving the round keys from the cipher key is the called the AES Key Expansion.
 *
 *
 *
 *
 *	AES Key Expansion or AES Key Scheduling:
 *		What is AES Key Expansion, The AES Key Expansion Algorithm or AES Key Scheduling 
 *		is a key scheduler used by AES Algorithm.
 *
 *		The AES key expansion algorithm is a crucial part of the AES encryption process.
 *		This Algorithm generates a series of round keys from the original cipher key. 
 *		These round keys are used in each encryption or decryption round.
 *
 *		Note: 
 *		Bear in mind that each round has its own key generated by the AES key expansion algorithm from the encryption key.
 *
 *		The AES Key Expansion algorithms is defined as follow:
 *			Initial Key: The user provides the original key (128, 192, or 256 bits).
 *			Rounds and Round Keys: AES operates in rounds (10, 12, or 14 rounds depending on key size), and each round requires its own unique round key.
 *			Word Formation: The original key is split into 32-bit words, which are used to generate new words for the expanded key.
 *			RotWord & SubWord: The RotWord operation rotates the bytes of a word, and SubWord applies the S-box substitution to each byte.
 *			Rcon (Round Constant): A round-dependent constant is XORed with the transformed word to increase variability in the round keys.
 *			XOR Operations: New words are generated by XORing previous words, ensuring that each round key is unique.
 *
 *			RotWord (Rotate Word)
 *			SubWord (Substitute Word)
 *			Rcon (Round Constant)
 *			XOR Operation
 *
 */

#include "aes.h"

#include <emmintrin.h>
#include <wmmintrin.h>
#include <immintrin.h>
#include <xmmintrin.h>

/////////////////////////////////////
//
//
//	    AES Counter
//
//
////////////////////////////////////

aes_status_t __attribute__((alias("aes_ctr_enc"))) aes_ctr_dec(byte_t *out, size_t o_sz, const iv_t nonce, const byte_t *restrict in, size_t i_sz, const aes_ctx_t *ctx);

/**
* @prototype aes_ctr_enc/aes_ctr_dec
*
* @brief  That function encrypt your data with
* 	AES-CTR mode operation.
*
*	This implementation work with Counter/LFSR
*
*	The structure of the counter is just a random nonce of 8, 12, or 16 bytes.
*	A nonce is just a random bytes, The counter is just a integer and start at 0.
*
*	So the High part of the Counter structure is the nonce and low part is the counter.
*
*	NOTE: In some implementation the counter is in big-endian take care of it.
*	WARNING: The user should not use the same IV (Same nonce with same key for sure), in case
*	of this behavior is performed this implementation is vulnerable to key-reused attack because AES-CTR transform
*	a block cipher in stream cipher.
*
* @param[in] byte_t: 		*out	Pointer to the output buffer where the encrypted data will be stored.
* @param[in] size_t:		o_sz	This value is the size of the output buffer.
* @param[in] const iv_t:    nonce	The nonce is just random value generaly 96 bits and the last 32 bits is the counter. So 16 bytes
* @param[in] const byte_t:	*in		This pointer is the input buffer, there is the data you can encrypt.
* @param[in] size_t:		i_sz	This is the size of the input bytes you want encrypt.
* @param[in] aes_ctx_t:		ctx		There is the context of your aes session contain the key, size of the key (etc...).
* 
*
* @return aes_status_t AES_OK if success otherwise is an error.
*/

aes_status_t	aes_ctr_enc(byte_t *out, size_t o_sz, const iv_t nonce, const byte_t *restrict in, size_t i_sz, const aes_ctx_t *ctx)
{
	if (!ctx || !out || !in || (o_sz < i_sz))
		return (AES_ERR);

	__m128i state = _mm_setzero_si128();
	__m128i feedback = _mm_setzero_si128();
	uint32_t *cnt = (uint32_t *)(nonce + 0xC);
	uint32_t save = *cnt;

	size_t NR = (ctx->key_size == AES_KEY_128
		? AES_128_NR 
		: ctx->key_size == AES_KEY_192 
		? AES_192_NR
		: AES_256_NR);

	// How Many iterations of 16 bytes Blocks which represent the number of state ?
	size_t blocks = (i_sz & 0xF ?  -~(i_sz >> 0x4) : (i_sz >> 0x4));

	for (size_t i = 0; i < blocks; i++) {

		_mm_prefetch((__m128i*)(in + 0x20), _MM_HINT_T0);

		// Load State
		state = _mm_loadu_si128( &((__m128i*)in)[i]);

		feedback = _mm_loadu_si128((__m128i*)nonce);

		// Xor State with first round Key (This XOR is equal to first AddRounKey Transformation)
		feedback = AddRoundKey(feedback, ctx->key.sched[0x0]);
        
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x1]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x2]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x3]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x4]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x5]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x6]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x7]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x8]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x9]);

		if (NR >= AES_192_NR) {
			feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0xa]);
			feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0xb]);

			if (NR == AES_256_NR) {
				feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0xc]);
				feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0xe]);
			}
		}

        feedback = _mm_aesenclast_si128(feedback, ctx->key.sched[NR]);

        state = _mm_xor_si128(feedback, state);
		
		_mm_storeu_si128(&((__m128i*)out)[i], state);

		*cnt += 0x01000000;
	}

	*cnt = save;

	return (AES_OK);
}

