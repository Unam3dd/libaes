/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   aes_gcm.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: stales <stales@student.42angouleme.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 12:46:51 by stales            #+#    #+#             */
/*   Updated: 2024/12/21 11:07:29 by stales           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
 * 										AES Algorithm
 *
 * 	Cipher Key:
 * 		AES is a symmetric key encryption algorithm (The same key is used to encrypt and decrypt). 
 * 		It uses a cipher key whose length is 128 bits, 192 bits or 256 bits. 
 * 		The AES algorithm with a cipher key of length 128, 192, 256 bits is denoted 
 *		AES-128, AES-192, AES-256, respectively.
 *
 *
 *
 *	State:
 *		The process of encryption/decryption of plaintext/ciphertext to ciphertext/plaintext
 *		generates intermediate 128-bit results. These intermediate results are referred to as the
 *		State.
 *
 *
 *
 * 	Data Blocks:
 * 		AES operates on an input data block of 128 bits and its output is also a data block of
 * 		128 bits. 
 *
 * 		(Note) The size of an "Data blocks" is alway 128 bits even if use 192 or 256 bits AES algorithms
 * 		The principal difference reside in the key, the key size must be changed if you use AES-128,192 or 256 bits
 *		but not Data blocks.
 *
 *
 *
 *	Round Keys:
 *		AES-128, AES-192, and AES-256 algorithms expand the cipher key to 10, 12, and 14
 *		round keys, respectively. The length of each round key is 128 bits. The algorithm for
 *		deriving the round keys from the cipher key is the called the AES Key Expansion.
 *
 *
 *
 *
 *	AES Key Expansion or AES Key Scheduling:
 *		What is AES Key Expansion, The AES Key Expansion Algorithm or AES Key Scheduling 
 *		is a key scheduler used by AES Algorithm.
 *
 *		The AES key expansion algorithm is a crucial part of the AES encryption process.
 *		This Algorithm generates a series of round keys from the original cipher key. 
 *		These round keys are used in each encryption or decryption round.
 *
 *		Note: 
 *		Bear in mind that each round has its own key generated by the AES key expansion algorithm from the encryption key.
 *
 *		The AES Key Expansion algorithms is defined as follow:
 *			Initial Key: The user provides the original key (128, 192, or 256 bits).
 *			Rounds and Round Keys: AES operates in rounds (10, 12, or 14 rounds depending on key size), and each round requires its own unique round key.
 *			Word Formation: The original key is split into 32-bit words, which are used to generate new words for the expanded key.
 *			RotWord & SubWord: The RotWord operation rotates the bytes of a word, and SubWord applies the S-box substitution to each byte.
 *			Rcon (Round Constant): A round-dependent constant is XORed with the transformed word to increase variability in the round keys.
 *			XOR Operations: New words are generated by XORing previous words, ensuring that each round key is unique.
 *
 *			RotWord (Rotate Word)
 *			SubWord (Substitute Word)
 *			Rcon (Round Constant)
 *			XOR Operation
 *
 */

#include "aes.h"
#include "gf.h"

#include <emmintrin.h>
#include <smmintrin.h>
#include <wmmintrin.h>
#include <immintrin.h>
#include <xmmintrin.h>

/////////////////////////////////////
//
//
//		Create Hash SubKey
//
//
////////////////////////////////////

static __m128i	create_hash_subkey(size_t NR, const aes_ctx_t *ctx)
{
	__m128i	hash_subkey = _mm_setzero_si128();

	// Xor State with first round Key (This XOR is equal to first AddRounKey Transformation)
	hash_subkey = AddRoundKey(hash_subkey, ctx->key.sched[0x0]);
        
	hash_subkey = _mm_aesenc_si128(hash_subkey, ctx->key.sched[0x1]);
	hash_subkey = _mm_aesenc_si128(hash_subkey, ctx->key.sched[0x2]);
	hash_subkey = _mm_aesenc_si128(hash_subkey, ctx->key.sched[0x3]);
	hash_subkey = _mm_aesenc_si128(hash_subkey, ctx->key.sched[0x4]);
	hash_subkey = _mm_aesenc_si128(hash_subkey, ctx->key.sched[0x5]);
	hash_subkey = _mm_aesenc_si128(hash_subkey, ctx->key.sched[0x6]);
	hash_subkey = _mm_aesenc_si128(hash_subkey, ctx->key.sched[0x7]);
	hash_subkey = _mm_aesenc_si128(hash_subkey, ctx->key.sched[0x8]);
	hash_subkey = _mm_aesenc_si128(hash_subkey, ctx->key.sched[0x9]);

	if (NR >= AES_192_NR) {
		hash_subkey = _mm_aesenc_si128(hash_subkey, ctx->key.sched[0xa]);
		hash_subkey = _mm_aesenc_si128(hash_subkey, ctx->key.sched[0xb]);

		if (NR == AES_256_NR) {
			hash_subkey = _mm_aesenc_si128(hash_subkey, ctx->key.sched[0xc]);
			hash_subkey = _mm_aesenc_si128(hash_subkey, ctx->key.sched[0xe]);
		}
	}

	hash_subkey = _mm_aesenclast_si128(hash_subkey, ctx->key.sched[NR]);

	return (hash_subkey);
}

/////////////////////////////////////
//
//
//	    AES Galois Counter Mode
//
//
////////////////////////////////////

aes_status_t __attribute__((alias("aes_gcm_enc"))) aes_gcm_dec(aes_gcm_counter_t *out, const iv_t nonce, const byte_t *restrict aad, const byte_t *restrict in, size_t i_sz, const aes_ctx_t *ctx);


aes_status_t	aes_gcm_enc(aes_gcm_counter_t *out, const iv_t nonce, const byte_t *restrict aad, const byte_t *restrict in, size_t i_sz, const aes_ctx_t *ctx)
{
	if (!ctx || !out || !in || !aad || !out->out || (out->size < i_sz))
		return (AES_ERR);

	__m128i state = _mm_setzero_si128();
	__m128i feedback = _mm_setzero_si128();
	__m128i first = _mm_setzero_si128();
	__m128i hash_subkey = _mm_setzero_si128();
	//__m128i current_aad = _mm_loadu_si128(aad);

	uint32_t *cnt = (uint32_t *)(nonce + 0xC);
	uint32_t save = *cnt;

	size_t NR = (ctx->key_size == AES_KEY_128
		? AES_128_NR 
		: ctx->key_size == AES_KEY_192 
		? AES_192_NR
		: AES_256_NR);

	hash_subkey = create_hash_subkey(NR, ctx);

	// How Many iterations of 16 bytes Blocks which represent the number of state ?
	size_t blocks = (i_sz & 0xF ?  -~(i_sz >> 0x4) : (i_sz >> 0x4));

	for (size_t i = 0; i < blocks; i++) {

		// Prefetching
		_mm_prefetch((__m128i*)(in + 0x20), _MM_HINT_T0);

		// Load State
		state = _mm_loadu_si128( &((__m128i*)in)[i]);

		feedback = _mm_loadu_si128((__m128i*)nonce);

		// Xor State with first round Key (This XOR is equal to first AddRounKey Transformation)
		feedback = AddRoundKey(feedback, ctx->key.sched[0x0]);
        
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x1]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x2]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x3]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x4]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x5]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x6]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x7]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x8]);
		feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0x9]);

		if (NR >= AES_192_NR) {
			feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0xa]);
			feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0xb]);

			if (NR == AES_256_NR) {
				feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0xc]);
				feedback = _mm_aesenc_si128(feedback, ctx->key.sched[0xe]);
			}
		}

        feedback = _mm_aesenclast_si128(feedback, ctx->key.sched[NR]);
		
		state = _mm_xor_si128(feedback, state);
		
		_mm_storeu_si128(&((__m128i*)out->out)[i], state);

		if (i == 0) {
		}
		
		*cnt += 0x01000000;
	}

	out->tag = _mm_xor_si128(first, hash_subkey);
	
	*cnt = save;

	return (AES_OK);
}

