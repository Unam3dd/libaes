/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   aes_ecb.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: stales <stales@student.42angouleme.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 12:46:51 by stales            #+#    #+#             */
/*   Updated: 2024/12/05 01:45:10 by stales           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
 * 										AES Algorithm
 *
 * 	Cipher Key:
 * 		AES is a symmetric key encryption algorithm (The same key is used to encrypt and decrypt). 
 * 		It uses a cipher key whose length is 128 bits, 192 bits or 256 bits. 
 * 		The AES algorithm with a cipher key of length 128, 192, 256 bits is denoted 
 *		AES-128, AES-192, AES-256, respectively.
 *
 *
 *
 *	State:
 *		The process of encryption/decryption of plaintext/ciphertext to ciphertext/plaintext
 *		generates intermediate 128-bit results. These intermediate results are referred to as the
 *		State.
 *
 *
 *
 * 	Data Blocks:
 * 		AES operates on an input data block of 128 bits and its output is also a data block of
 * 		128 bits. 
 *
 * 		(Note) The size of an "Data blocks" is alway 128 bits even if use 192 or 256 bits AES algorithms
 * 		The principal difference reside in the key, the key size must be changed if you use AES-128,192 or 256 bits
 *		but not Data blocks.
 *
 *
 *
 *	Round Keys:
 *		AES-128, AES-192, and AES-256 algorithms expand the cipher key to 10, 12, and 14
 *		round keys, respectively. The length of each round key is 128 bits. The algorithm for
 *		deriving the round keys from the cipher key is the called the AES Key Expansion.
 *
 *
 *
 *
 *	AES Key Expansion or AES Key Scheduling:
 *		What is AES Key Expansion, The AES Key Expansion Algorithm or AES Key Scheduling 
 *		is a key scheduler used by AES Algorithm.
 *
 *		The AES key expansion algorithm is a crucial part of the AES encryption process.
 *		This Algorithm generates a series of round keys from the original cipher key. 
 *		These round keys are used in each encryption or decryption round.
 *
 *		Note: 
 *		Bear in mind that each round has its own key generated by the AES key expansion algorithm from the encryption key.
 *
 *		The AES Key Expansion algorithms is defined as follow:
 *			Initial Key: The user provides the original key (128, 192, or 256 bits).
 *			Rounds and Round Keys: AES operates in rounds (10, 12, or 14 rounds depending on key size), and each round requires its own unique round key.
 *			Word Formation: The original key is split into 32-bit words, which are used to generate new words for the expanded key.
 *			RotWord & SubWord: The RotWord operation rotates the bytes of a word, and SubWord applies the S-box substitution to each byte.
 *			Rcon (Round Constant): A round-dependent constant is XORed with the transformed word to increase variability in the round keys.
 *			XOR Operations: New words are generated by XORing previous words, ensuring that each round key is unique.
 *
 *			RotWord (Rotate Word)
 *			SubWord (Substitute Word)
 *			Rcon (Round Constant)
 *			XOR Operation
 *
 */

#include "aes.h"

#include <emmintrin.h>
#include <wmmintrin.h>

/////////////////////////////////////
//
//
//	    AES ELECTRONIC CODE BOOKS
//
//
////////////////////////////////////

aes_status_t	aes_ecb_enc(byte_t *out, size_t o_sz, const byte_t *restrict in, size_t i_sz, const aes_ctx_t *ctx)
{
	if (!ctx || !out || !in || (o_sz < i_sz))
		return (AES_ERR);

	__m128i state = _mm_setzero_si128();

	size_t i = 0;

	size_t NR = (ctx->key_size == AES_KEY_128
		? AES_128_NR 
		: ctx->key_size == AES_KEY_192 
		? AES_192_NR
		: AES_256_NR);

	// How Many iterations of 16 bytes Blocks which represent the number of state ?
	size_t blocks = (i_sz & 0xF ?  -~(i_sz >> 0x4) : (i_sz >> 0x4));

	for (i = 0; i < blocks; i++) {

		// Load State
		state = _mm_loadu_si128( &((__m128i*)in)[i]);

		// Xor State with first round Key (This XOR is equal to first AddRounKey Transformation)
		state = AddRoundKey(state, ctx->key.sched[0]);

		state = _mm_aesenc_si128(state, ctx->key.sched[1]);
		state = _mm_aesenc_si128(state, ctx->key.sched[2]);
		state = _mm_aesenc_si128(state, ctx->key.sched[3]);
		state = _mm_aesenc_si128(state, ctx->key.sched[4]);
		state = _mm_aesenc_si128(state, ctx->key.sched[5]);
		state = _mm_aesenc_si128(state, ctx->key.sched[6]);
		state = _mm_aesenc_si128(state, ctx->key.sched[7]);
		state = _mm_aesenc_si128(state, ctx->key.sched[8]);
		state = _mm_aesenc_si128(state, ctx->key.sched[9]);

		if (NR >= AES_192_NR) {
			state = _mm_aesenc_si128(state, ctx->key.sched[10]);
			state = _mm_aesenc_si128(state, ctx->key.sched[11]);

			if (NR == AES_256_NR) {
				state = _mm_aesenc_si128(state, ctx->key.sched[12]);
				state = _mm_aesenc_si128(state, ctx->key.sched[13]);
			}
		}

		//      a[127:0] := ShiftRows(a[127:0])
		//      a[127:0] := SubBytes(a[127:0])
		//      dst[127:0] := a[127:0] (AddRoundKey) XOR RoundKey[127:0]
		state = _mm_aesenclast_si128(state, ctx->key.sched[NR]);

		_mm_storeu_si128(&((__m128i*)out)[i], state);
	}


	return (AES_OK);
}

aes_status_t	aes_ecb_dec(byte_t *out, size_t o_sz, const byte_t *restrict in, size_t i_sz, const aes_ctx_t *ctx)
{
	if (!ctx || !out || !in || (o_sz < i_sz))
		return (AES_ERR);

	__m128i state = _mm_setzero_si128();
	size_t i = 0;

	size_t NR = (ctx->key_size == AES_KEY_128
		? AES_128_NR 
		: ctx->key_size == AES_KEY_192 
		? AES_192_NR
		: AES_256_NR);
	
	size_t blocks = (i_sz & 0xF ?  -~(i_sz >> 0x4) : (i_sz >> 0x4));

	for (i = 0; i < blocks; i++) {
		state = _mm_loadu_si128( &((__m128i*)in)[i]);

        state = AddRoundKey(state, ctx->key.sched[NR]);
        state = _mm_aesdec_si128(state, _mm_aesimc_si128(ctx->key.sched[NR - 1]));
        state = _mm_aesdec_si128(state, _mm_aesimc_si128(ctx->key.sched[NR - 2]));
        state = _mm_aesdec_si128(state, _mm_aesimc_si128(ctx->key.sched[NR - 3]));
        state = _mm_aesdec_si128(state, _mm_aesimc_si128(ctx->key.sched[NR - 4]));
        state = _mm_aesdec_si128(state, _mm_aesimc_si128(ctx->key.sched[NR - 5]));
        state = _mm_aesdec_si128(state, _mm_aesimc_si128(ctx->key.sched[NR - 6]));
        state = _mm_aesdec_si128(state, _mm_aesimc_si128(ctx->key.sched[NR - 7]));
        state = _mm_aesdec_si128(state, _mm_aesimc_si128(ctx->key.sched[NR - 8]));
        state = _mm_aesdec_si128(state, _mm_aesimc_si128(ctx->key.sched[NR - 9]));

		if (NR >= AES_192_NR) {
			state = _mm_aesdec_si128(state, _mm_aesimc_si128(ctx->key.sched[NR - 10]));
			state = _mm_aesdec_si128(state, _mm_aesimc_si128(ctx->key.sched[NR - 11]));

			if (NR == AES_256_NR) {
				state = _mm_aesdec_si128(state, _mm_aesimc_si128(ctx->key.sched[NR - 12]));
				state = _mm_aesdec_si128(state, _mm_aesimc_si128(ctx->key.sched[NR - 13]));
			}
		}
        
        state = _mm_aesdeclast_si128(state, ctx->key.sched[0]);
		_mm_storeu_si128(&((__m128i*)out)[i], state);
	}

	return (AES_OK);
}
